// @ts-nocheck
// This file is auto-generated by Specta. Do not edit manually.


// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async vrchatLogin(email: string, password: string) : Promise<Result<LoginResult, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("vrchat_login", { email, password }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vrchatVerify2fa(code: string, method: string) : Promise<Result<boolean, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("vrchat_verify_2fa", { code, method }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vrchatGetCurrentUser() : Promise<Result<User, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("vrchat_get_current_user") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vrchatUpdateStatus(status: UserStatus, statusDescription: string) : Promise<Result<User, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("vrchat_update_status", { status, statusDescription }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vrchatLogout() : Promise<Result<null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("vrchat_logout") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vrchatGetOnlineFriends() : Promise<Result<LimitedUserFriend[], VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("vrchat_get_online_friends") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vrchatGetUploadedWorlds() : Promise<Result<LimitedWorld[], VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("vrchat_get_uploaded_worlds") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vrchatGetUploadedAvatars() : Promise<Result<LimitedAvatar[], VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("vrchat_get_uploaded_avatars") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getOnlineFriends() : Promise<Result<LimitedUserFriend[], VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_online_friends") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAllFriends() : Promise<Result<LimitedUserFriend[], VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_friends") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getUser(userId: string) : Promise<Result<LimitedUserFriend | null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_user", { userId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getUserById(userId: string) : Promise<Result<User, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_user_by_id", { userId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isFriend(userId: string) : Promise<Result<boolean, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_friend", { userId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isUserOnline(userId: string) : Promise<Result<boolean, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_user_online", { userId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vrchatCheckSession() : Promise<Result<boolean, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("vrchat_check_session") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vrchatClearSession() : Promise<Result<null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("vrchat_clear_session") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async websocketStart() : Promise<Result<null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("websocket_start") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async websocketStop() : Promise<Result<null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("websocket_stop") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveCurrentAccount(user: User) : Promise<Result<null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_current_account", { user }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAllAccounts() : Promise<Result<StoredAccount[], VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_accounts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async switchAccount(userId: string) : Promise<Result<User, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("switch_account", { userId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeAccount(userId: string) : Promise<Result<null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_account", { userId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async clearAllAccounts() : Promise<Result<null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_all_accounts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loadLastAccount() : Promise<Result<User | null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_last_account") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSettings() : Promise<Result<AppSettings, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveSettings(settings: AppSettings) : Promise<Result<null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_settings", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDeveloperMode() : Promise<Result<boolean, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_developer_mode") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setDeveloperMode(enabled: boolean) : Promise<Result<null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_developer_mode", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getBackendLogs() : Promise<Result<LogEntry[], VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_backend_logs") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async clearBackendLogs() : Promise<Result<null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_backend_logs") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async exportBackendLogs() : Promise<Result<string, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_backend_logs") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getVrchatStatus() : Promise<Result<VRChatStatusResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_vrchat_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dbListTables() : Promise<Result<TableInfo[], VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("db_list_tables") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dbGetTableSchema(tableName: string) : Promise<Result<ColumnInfo[], VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("db_get_table_schema", { tableName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dbGetTableData(tableName: string, limit: number | null, offset: number | null) : Promise<Result<QueryResult, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("db_get_table_data", { tableName, limit, offset }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dbGetTableCount(tableName: string) : Promise<Result<number, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("db_get_table_count", { tableName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dbExecuteQuery(query: string) : Promise<Result<QueryResult, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("db_execute_query", { query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkImageCached(url: string) : Promise<Result<string | null, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_image_cached", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cacheImage(url: string) : Promise<Result<string, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cache_image", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCacheDirectory() : Promise<Result<string, VRCError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_cache_directory") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Age verification status
 * `verified` is obsolete. according to the unofficial docs, Users who have verified and are 18+ can switch to `plus18` status.
 */
export type AgeVerificationStatus = 
/**
 * Age verification status is hidden
 */
"hidden" | 
/**
 * Legacy verified status (obsolete)
 */
"verified" | 
/**
 * User is verified to be 18+
 */
"18+"
export type AppSettings = { developer_mode: boolean }
export type AvatarPerformance = { android?: string | null; ios?: string | null; standalonewindows?: string | null }
export type AvatarStyles = { primary?: string | null; secondary?: string | null }
export type Badge = { badgeId: string; badgeName?: string; badgeDescription?: string; assignedAt?: string | null; showcased?: boolean; badgeImageUrl?: string | null; updatedAt?: string | null; hidden?: boolean }
export type ColumnInfo = { cid: number; name: string; type: string; notnull: number; dflt_value: string | null; pk: number }
/**
 * User's developer type/staff level
 */
export type DeveloperType = 
/**
 * Normal user
 */
"none" | 
/**
 * Trusted user
 */
"trusted" | 
/**
 * VRChat Developer/Staff
 */
"internal" | 
/**
 * VRChat Moderator
 */
"moderator"
export type DiscordDetails = { globalName?: string | null; id?: string | null }
/**
 * Friend request status
 */
export type FriendRequestStatus = 
/**
 * No friend request
 */
"" | 
/**
 * Outgoing friend request pending
 */
"outgoing" | 
/**
 * Incoming friend request pending
 */
"incoming" | 
/**
 * Completed friend request
 */
"completed"
export type GoogleDetails = { emailMatches?: boolean | null }
export type LimitedAvatar = { id: string; name: string; description?: string | null; authorId?: string | null; authorName?: string | null; imageUrl?: string | null; thumbnailImageUrl?: string | null; assetUrl?: string | null; unityPackageUrl?: string | null; releaseStatus?: ReleaseStatus; featured?: boolean | null; searchable?: boolean | null; listingDate?: string | null; createdAt?: string | null; updatedAt?: string | null; version?: number | null; tags?: string[]; performance?: AvatarPerformance | null; styles?: AvatarStyles | null; unityPackages?: UnityPackageSummary[] }
export type LimitedUserFriend = { id: string; displayName: string; bio?: string; bioLinks?: string[]; currentAvatarImageUrl?: string | null; currentAvatarThumbnailImageUrl?: string | null; currentAvatarTags?: string[]; developerType?: DeveloperType; friendKey?: string | null; isFriend?: boolean; imageUrl?: string | null; lastPlatform?: string | null; location?: string | null; lastLogin?: string | null; lastActivity?: string | null; lastMobile?: string | null; platform?: string; profilePicOverride?: string | null; profilePicOverrideThumbnail?: string | null; status?: UserStatus; statusDescription?: string; tags?: string[]; userIcon?: string | null }
export type LimitedWorld = { id: string; name: string; description?: string | null; authorId?: string | null; authorName?: string | null; imageUrl?: string | null; thumbnailImageUrl?: string | null; releaseStatus?: ReleaseStatus; publicationDate?: string | null; createdAt?: string | null; updatedAt?: string | null; labsPublicationDate?: string | null; visits?: number | null; favorites?: number | null; popularity?: number | null; occupants?: number | null; capacity?: number | null; recommendedCapacity?: number | null; heat?: number | null; organization?: string | null; previewYoutubeId?: string | null; tags?: string[]; unityPackages?: UnityPackageSummary[] }
export type LogEntry = { timestamp: string; level: string; source: string; module: string; message: string }
export type LoginResult = { type: "Success"; user: User } | { type: "TwoFactorRequired"; methods: string[] }
/**
 * Sort order for API queries
 */
export type OrderOption = 
/**
 * Ascending order
 */
"ascending" | 
/**
 * Descending order
 */
"descending"
export type PastDisplayName = { displayName: string; updatedAt?: string | null; reverted?: boolean | null }
/**
 * Avatar performance ratings
 */
export type PerformanceRatings = 
/**
 * No rating
 */
"None" | 
/**
 * Excellent performance
 */
"Excellent" | 
/**
 * Good performance
 */
"Good" | 
/**
 * Medium performance
 */
"Medium" | 
/**
 * Poor performance
 */
"Poor" | 
/**
 * Very poor performance
 */
"VeryPoor"
export type QueryResult = { columns: string[]; rows: (Partial<{ [key in string]: string }>)[]; rows_affected: number | null }
/**
 * Release status of avatars and worlds
 */
export type ReleaseStatus = 
/**
 * Publicly released
 */
"public" | 
/**
 * Private/restricted access
 */
"private" | 
/**
 * Hidden from listings
 */
"hidden" | 
/**
 * Filter for all statuses
 */
"all"
export type StatusIndicator = "none" | "minor" | "major" | "critical"
export type StatusPage = { id: string; name: string; url: string; time_zone: string; updated_at: string }
export type SteamDetails = { avatar?: string | null; avatarfull?: string | null; avatarhash?: string | null; avatarmedium?: string | null; communityvisibilitystate?: number | null; gameextrainfo?: string | null; gameid?: string | null; loccountrycode?: string | null; locstatecode?: string | null; personaname?: string | null; personastate?: number | null; personastateflags?: number | null; primaryclanid?: string | null; profilestate?: number | null; profileurl?: string | null; steamid?: string | null; timecreated?: number | null }
export type StoredAccount = { user_id: string; username: string; display_name: string; avatar_url?: string | null; avatar_fallback_url?: string | null; auth_cookie: string | null; two_factor_cookie: string | null; last_login: string }
export type SystemStatus = { 
/**
 * Indicator of system status
 */
indicator: StatusIndicator; 
/**
 * Human-readable status description
 */
description: string }
export type TableInfo = { name: string; sql: string }
export type UnityPackageSummary = { id?: string | null; assetUrl?: string | null; assetVersion?: number | null; platform?: string | null; unityVersion?: string | null; createdAt?: string | null; performanceRating?: string | null; scanStatus?: string | null; variant?: string | null; unitySortNumber?: number | null; impostorizerVersion?: string | null }
export type UpdateStatusRequest = { status: UserStatus; statusDescription: string }
export type User = { id: string; username?: string; displayName: string; acceptedPrivacyVersion?: number | null; acceptedTosVersion?: number | null; accountDeletionDate?: string | null; state?: string; status?: UserStatus; statusDescription?: string; statusFirstTime?: boolean | null; statusHistory?: string[]; bio?: string; bioLinks?: string[]; ageVerificationStatus?: AgeVerificationStatus; ageVerified?: boolean | null; isAdult?: boolean | null; dateJoined?: string | null; lastLogin?: string | null; lastActivity?: string | null; lastPlatform?: string | null; lastMobile?: string | null; platform?: string; platformHistory?: string[]; location?: string | null; travelingToWorld?: string | null; travelingToLocation?: string | null; travelingToInstance?: string | null; homeLocation?: string | null; instanceId?: string | null; worldId?: string | null; allowAvatarCopying?: boolean | null; twoFactorAuthEnabled?: boolean | null; twoFactorAuthEnabledDate?: string | null; currentAvatar?: string | null; fallbackAvatar?: string | null; currentAvatarTags?: string[]; profilePicOverride?: string | null; profilePicOverrideThumbnail?: string | null; userIcon?: string | null; currentAvatarImageUrl?: string | null; currentAvatarThumbnailImageUrl?: string | null; bannerId?: string | null; bannerUrl?: string | null; pronouns?: string | null; languages?: string[] | null; pronounsHistory?: string[]; friends?: string[]; friendGroupNames?: string[]; friendKey?: string | null; friendRequestStatus?: FriendRequestStatus; pastDisplayNames?: PastDisplayName[] | null; badges?: Badge[] | null; tags?: string[]; isFriend?: boolean | null; note?: string | null; developerType?: DeveloperType; isBoopingEnabled?: boolean | null; receiveMobileInvitations?: boolean | null; hideContentFilterSettings?: boolean | null; hasBirthday?: boolean | null; hasEmail?: boolean | null; hasPendingEmail?: boolean | null; hasLoggedInFromClient?: boolean | null; unsubscribe?: boolean | null; updatedAt?: string | null; emailVerified?: boolean | null; obfuscatedEmail?: string | null; userLanguage?: string | null; userLanguageCode?: string | null; discordId?: string | null; discordDetails?: DiscordDetails | null; googleId?: string | null; googleDetails?: GoogleDetails | null; steamId?: string | null; steamDetails?: SteamDetails | null; oculusId?: string | null; picoId?: string | null; viveId?: string | null }
/**
 * State of the user
 */
export type UserState = 
/**
 * User is offline
 */
"offline" | 
/**
 * User is active
 */
"active" | 
/**
 * User is online
 */
"online"
/**
 * User's current status
 */
export type UserStatus = 
/**
 * User is online and active
 */
"active" | 
/**
 * User is online and auto accepting invitations to join
 */
"join me" | 
/**
 * User is online but is hiding their location and requires invitation to join
 */
"ask me" | 
/**
 * User is busy
 */
"busy" | 
/**
 * User is offline
 */
"offline"
/**
 * Main error type for VRChat API operations
 */
export type VRCError = 
/**
 * Network-related errors
 */
{ type: "Network"; data: string } | 
/**
 * HTTP errors with status code
 */
{ type: "Http"; data: { status: number; message: string } } | 
/**
 * Authentication errors
 */
{ type: "Authentication"; data: string } | 
/**
 * Rate limiting error
 */
{ type: "RateLimit"; data: string } | 
/**
 * JSON parsing errors
 */
{ type: "Parse"; data: string } | 
/**
 * Invalid input or request
 */
{ type: "InvalidInput"; data: string } | 
/**
 * Unknown or unexpected errors
 */
{ type: "Unknown"; data: string }
/**
 * Response from VRChat status API
 */
export type VRChatStatusResponse = { page: StatusPage; status: SystemStatus }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
